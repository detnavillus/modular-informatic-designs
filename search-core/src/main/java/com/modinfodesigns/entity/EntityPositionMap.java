package com.modinfodesigns.entity;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Iterator;

import java.util.Set;
import java.util.HashSet;

import com.modinfodesigns.property.quantity.IntegerRangeProperty;
import com.modinfodesigns.property.quantity.LongRangeProperty;

/**
 * Maps a conceptual 'entity'.  Contains one or more PhrasePositionMap(s) for each phrase that 
 * represents the 'entity'. An EntityPositionMap is generated by an IEntityExtractor implementation.
 * 
 * @author Ted Sullivan
 */
public class EntityPositionMap
{
  // Map of first or leading Token in a phrase to PhrasePositionMap List
  private HashMap<String,ArrayList<PhrasePositionMap>> mapperMap = new HashMap<String,ArrayList<PhrasePositionMap>>( );
    
  // Map of all Tokens to PhrasePositionMap List
  private HashMap<String,ArrayList<PhrasePositionMap>> tokenMap = new HashMap<String,ArrayList<PhrasePositionMap>>( );
    
  private String prefixString;

  private String postfixString;
    
  public EntityPositionMap(  ) {  }
   
    
  public void setPrefixString( String prefixString )
  {
    this.prefixString = prefixString;
  }
    
  public String getPrefixString(  )
  {
    return this.prefixString;
  }
    
  public void setPostfixString( String postfixString )
  {
    this.postfixString = postfixString;
  }
    
  public String getPostfixString(  )
  {
    return this.postfixString;
  }
    
    
  public void addPhrasePositionMap( PhrasePositionMap eMapper )
  {
    ArrayList<PhrasePositionMap> mapList = mapperMap.get(eMapper.getFirstToken() );
    if (mapList == null)
    {
      mapList = new ArrayList<PhrasePositionMap>( );
      mapperMap.put( eMapper.getFirstToken( ), mapList );
    }
    	
    mapList.add( eMapper );
    addTokens( eMapper );
  }
    
  private void addTokens( PhrasePositionMap phraseMap )
  {
    String[] tokens = phraseMap.getEntityTokens( );
    if (tokens != null)
    {
      for (int i = 0, isz = tokens.length; i < isz; i++)
      {
        ArrayList<PhrasePositionMap> mapList = tokenMap.get( tokens[i] );
        if (mapList == null)
        {
          mapList = new ArrayList<PhrasePositionMap>( );
          tokenMap.put( tokens[i], mapList );
        }
    			
        mapList.add( phraseMap );
      }
    }
  }
    
  public List<PhrasePositionMap> getPhrasePositionMaps( )
  {
    ArrayList<PhrasePositionMap> allMappers = new ArrayList<PhrasePositionMap>( );
    for (Iterator<ArrayList<PhrasePositionMap>> listIt = mapperMap.values().iterator(); listIt.hasNext(); )
    {
      ArrayList<PhrasePositionMap> list = listIt.next();
      allMappers.addAll( list );
    }
    	
    return allMappers;
  }
    
  public List<PhrasePositionMap> getPhraseMapsStartingWith( String firstToken )
  {
    return mapperMap.get( firstToken );
  }
    
  public Iterator<String> getFirstTokens( )
  {
    return mapperMap.keySet().iterator( );
  }
    
  public List<PhrasePositionMap> getPhraseMapsForToken( String token )
  {
    return tokenMap.get( token );
  }
    
  public Iterator<String> getAllTokens( )
  {
    return tokenMap.keySet().iterator( );
  }
    
  /**
   * Returns EntityMapper entities for which there are word positions ...
   *
   * @return
   */
  public Set<String> getMappedPhrases(  )
  {
    return getMappedPhrases( false );
  }
    
  public Set<String> getMappedPhrases( boolean onlyExtracted )
  {
    HashSet<String> phraseSet = new HashSet<String>( );
    Iterator<ArrayList<PhrasePositionMap>> mapIt =  mapperMap.values().iterator( );
    while (mapIt.hasNext())
    {
      ArrayList<PhrasePositionMap> mapList = mapIt.next( );
      for (int i = 0, isz = mapList.size( ); i < isz; i++)
      {
        PhrasePositionMap eMapper = mapList.get( i );
        if (!onlyExtracted || (eMapper.getWordPositions( ) != null &&
                                eMapper.getWordPositions( ).size() > 0))
        {
          phraseSet.add( eMapper.getPhrase( ) );
        }
      }
    }
    	
    return phraseSet;
  }
    
    
  public List<IntegerRangeProperty> getWordPositions(  )
  {
    ArrayList<IntegerRangeProperty> ranges = new ArrayList<IntegerRangeProperty>( );
    Iterator<ArrayList<PhrasePositionMap>> mapIt =  mapperMap.values().iterator( );
    while (mapIt.hasNext())
    {
      ArrayList<PhrasePositionMap> mapList = mapIt.next( );
      for (int i = 0, isz = mapList.size( ); i < isz; i++)
      {
        PhrasePositionMap eMapper = mapList.get( i );
        List<IntegerRangeProperty> eMapperRanges = eMapper.getWordPositions( );
        if ( eMapperRanges != null )
        {
          ranges.addAll( eMapperRanges );
        }
      }
    }
    	
    return ranges;
  }
 
    
  public List<LongRangeProperty> getCharacterPositions(  )
  {
    return getCharacterPositions( 0L );
  }
    
  public List<LongRangeProperty> getCharacterPositions( long offset )
  {
    ArrayList<LongRangeProperty> ranges = new ArrayList<LongRangeProperty>( );
    Iterator<ArrayList<PhrasePositionMap>> mapIt =  mapperMap.values().iterator( );
    while (mapIt.hasNext())
    {
      ArrayList<PhrasePositionMap> mapList = mapIt.next( );
      for (int i = 0, isz = mapList.size( ); i < isz; i++)
      {
        PhrasePositionMap eMapper = mapList.get( i );
        List<LongRangeProperty> eMapperRanges = eMapper.getCharacterPositions( offset );
        if ( eMapperRanges != null )
        {
          ranges.addAll( eMapperRanges );
        }
      }
    }
    	
    return ranges;
  }
    
}
